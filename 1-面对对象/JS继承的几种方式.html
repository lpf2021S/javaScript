<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // # 1. 原型链继承
        function Father(name) {
            this.name = name;
            this.arr = [1, 2, 3]
        }
        Father.prototype.say = function() {
            console.log('say', this);
        }

        function Son(name, age) {
            this.age = age
            this.name = name
        }
        Son.prototype = new Father('张三');
        // (1). 无法传递参数
        // (2). 引用类型值会被公用
        // # 2. 构造函数继承
        function Son1(name, age) {
            Father.call(this, name)
            this.age = age
        }
        // (1).无法访问父类原型
        // (2).方法无法复用
        // # 3. 组合继承
        function Son2(name, age) {
            Father.call(this, name)
            this.age = age
        }
        Son2.prototype = new Father()
        console.log(new Son2('lpf', 22));
        // (1). 调用了两次Person,内存浪费
        // # 4.原型式继承
        const Father1 = {
            name: '李鹏飞',
            age: 18,
            arr: [5, 6, 7],
            say() {
                console.log(123);
            }
        }
        const Son3 = Object.create(Father1, {
            name: {
                value: '李鹏飞'
            }
        });
        // # 5.寄生式继承
        function Son4(name, age) {
            this.name = name
            this.age = age
        }
        Son4.prototype = Object.create(Father.prototype)
        let j = new Son4('lpf', 21)
        Son4.prototype.constructor = Son4;
        // 没用实现属性操作的复用
        // # 6. 组合寄生式继承
        function Son5(name, age) {
            Father.call(this.age)
            this.age = age
        }
        Son5.prototype = Object.create(Father.prototype)
        Son5.prototype.constructor = Son5;
        // 封装性不太好
        // # 7. ES6 extents
        class Father2 {
            constructor(name) {
                this.name = name
            }
            say() {
                console.log('21');
            }
        };
        class T extends Father2 {
            constructor(name, age) {
                super(name)
                this.age = age
            }
        }
    </script>
</body>

</html>