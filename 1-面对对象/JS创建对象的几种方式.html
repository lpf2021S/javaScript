<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS创建对象的几种方式</title>
</head>

<body>
    <script>
        // 1. 工厂模式 Factories Function
        const Person = function(name, age) {
            return {
                name,
                age,
                say() {
                    console.log(this.name, this.age);
                }
            }
        }
        const it = Person('李鹏飞', 18);
        // * 抽象化创建函数
        //  (1). 实例不能与Person建立关系
        //  (2). 方法不能重复利用，每个实例上是新的方法
        // ------------------------------------------------
        //  2.原型式
        function Student() {}
        Student.prototype.name = 'lsk';
        Student.prototype.age = 18;
        Student.prototype.arr = [1, 2, 3]
        Student.prototype.doHomework = function() {
            console.log(this.name + "正在做作业");
        }
        let stu1 = new Student();
        let stu2 = new Student();
        // (1). 无法传参提供初始值
        // (2). 引用值被所有对象共用
        // ------------------------------------------------
        // 3.构造函数式
        function Apple(title, price) {
            this.title = title
            this.price = price
            this.say = function() {
                console.log(this.title, this.price);
            }
        };
        //  (1). 方法重复创建
        //  (2). instanceOf能够判断类型
        //  new的原理
        //  (1). ## 使用new调用函数，而这个函数中有return，那它return出来的是什么
        //   构造函数有返回值的情况：当构造函数返回值为对象时，直接返回这个对象；否则返回new创建的对象
        //  (2). ## new 操作符做了哪些事情
        //    *  - 创建一个空的简单 JavaScript 对象 （即 {}） 
        //    *  - {} 添加__proto__属性,将该属性链接至构造函数的原型对象
        //    *  - 将新创建的{}作为 this 的上下文 
        //    *  - 如果该函数没有返回对象，则返回 this
        // ----------------------------------------------------
        // 4. 构造函数加原型创建对象
        function Hero(name, skil) {
            this.name = name
            this.skil = skil
        }
        Hero.prototype.useSkil = function() {
            console.log(`英雄${this.name}使用了${this.skil}`);
        };
        // 封装性不太好
        // ----------------------------------------------------
        // 5.动态原型模式
        function Banana(name, price) {
            this.name = name
            this.price = price
            if (typeof this.say !== 'function') {
                Person.prototype.say = function() {
                    console.log(this.name, this.price)
                }
            }
        };
        // 6.寄生构造函数模式
        function Personx(name, job) {
            let obj = new Object()
            obj.name = name
            obj.job = job
            obj.sayName = function() {
                console.log(this.name)
            }
            return obj
        }
    </script>
</body>

</html>